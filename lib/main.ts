import { readdir, writeFile } from "fs/promises";
import { dirname, relative, resolve } from "path";

import { type Options as FormatOptions, format } from "prettier";
import { type PluginOption } from "vite";

const COMMENT = "File automatically generated by `vite-plugin-module-list`";

function generateModuleList(
  filePathList: string[],
  rootPath: string,
  outputPath: string,
) {
  const outputRootPath = dirname(outputPath);
  const { stringify: formatValue } = JSON;
  const moduleList = `[ ${filePathList
    .map((filePath) => {
      const resolvedFilePath = resolve(rootPath, filePath);
      if (resolvedFilePath === outputPath) {
        return;
      }
      const relativeFilePath = relative(outputRootPath, resolvedFilePath);
      return `{ path: ${formatValue(
        filePath,
      )}, module: () => import(${formatValue(`./${relativeFilePath}`)}) }`;
    })
    .filter(Boolean)
    .join(",")} ]`;
  return `// ${COMMENT}\nexport default ${moduleList}`;
}

async function writeModuleList(
  rootPath: string,
  outputPath: string,
  formatOptions: FormatOptions | false = {},
) {
  const moduleList = await generateModuleList(
    await readdir(rootPath),
    rootPath,
    outputPath,
  );
  await writeFile(
    outputPath,
    formatOptions === false
      ? moduleList
      : await format(moduleList, {
          parser: "meriyah",
          ...formatOptions,
        }),
  );
}

export interface ModuleListOptions {
  /**
   * Path to the folder containing the modules to list.
   *
   * @defaultValue `"."`
   */
  rootPath?: string;
  /**
   * Path to the module into wich the module list is written.
   *
   * @defaultValue `${rootPath}/main.ts`.
   */
  outputPath?: string;
  /**
   * Prettier options. If explicitely set to false, the code is not formatted.
   *
   * @see {@link FormatOptions} for the list of options.
   */
  formatOptions?: FormatOptions | false;
}

export default function moduleList({
  rootPath = ".",
  outputPath = `${rootPath}/main.ts`,
  formatOptions,
}: ModuleListOptions): PluginOption {
  const resolvedRootPath = resolve(rootPath);
  return {
    name: "module-list",
    async configureServer(server) {
      await writeModuleList(rootPath, outputPath, formatOptions);
      server.watcher.on("all", async (eventName, filePath) => {
        if (eventName !== "add" && eventName !== "unlink") {
          return;
        }
        const resolvedFilePath = resolve(filePath);
        if (
          resolvedFilePath === outputPath ||
          !resolvedFilePath.startsWith(resolvedRootPath)
        ) {
          return;
        }
        await writeModuleList(rootPath, outputPath, formatOptions);
      });
    },
  };
}
