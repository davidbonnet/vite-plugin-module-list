import { readdir, writeFile } from "fs/promises";
import { dirname, relative, resolve } from "path";

import { type Options as FormatOptions, format } from "prettier";
import { type PluginOption } from "vite";

const COMMENT = "File automatically generated by `vite-plugin-module-list`";

/**
 * Generation mode:
 * - `full-dynamic`: Every found module is listed in an array with a `{ path, module: () => import() }` object description, `module` being a callback that does a dynamic import.
 * - `named-static`: Every found module has a reference of the same module name being re-exported.
 */
export type Mode = "full-dynamic" | "named-static";

function generateModuleList(
  filePathList: string[],
  rootPath: string,
  outputPath: string,
  mode: Mode,
) {
  const outputRootPath = dirname(outputPath);
  const { stringify: formatValue } = JSON;
  switch (mode) {
    case "full-dynamic": {
      const moduleList = `[ ${filePathList
        .map((filePath) => {
          const resolvedFilePath = resolve(rootPath, filePath);
          if (resolvedFilePath === outputPath) {
            return;
          }
          const relativeFilePath = relative(outputRootPath, resolvedFilePath);
          return `{ path: ${formatValue(
            filePath,
          )}, module: () => import(${formatValue(`./${relativeFilePath}`)}) }`;
        })
        .filter(Boolean)
        .join(",")} ]`;
      return `// ${COMMENT}\nexport default ${moduleList}`;
    }
    case "named-static": {
      const moduleList = filePathList
        .map((filePath) => {
          const resolvedFilePath = resolve(rootPath, filePath);
          if (resolvedFilePath === outputPath) {
            return;
          }

          const relativeFilePath = relative(outputRootPath, resolvedFilePath);
          return `export { ${filePath.slice(
            0,
            filePath.lastIndexOf("."),
          )} } from ${formatValue(`./${relativeFilePath}`)}`;
        })
        .filter(Boolean)
        .join("\n");
      return `// ${COMMENT}\n${moduleList}`;
    }
  }
}

async function writeModuleList(
  rootPath: string,
  outputPath: string,
  formatOptions: FormatOptions | false = {},
  mode: Mode,
) {
  const moduleList = await generateModuleList(
    await readdir(rootPath),
    rootPath,
    outputPath,
    mode,
  );
  await writeFile(
    outputPath,
    formatOptions === false
      ? moduleList
      : await format(moduleList, {
          parser: "meriyah",
          ...formatOptions,
        }),
  );
}

/**
 * Plugin options.
 */
export type ModuleListOptions = {
  /**
   * Specifies how the modules are listed and exported.
   *
   * @defaultValue "full-dynamic"
   */
  mode?: Mode;
  /**
   * Path to the folder containing the modules to list.
   *
   * @defaultValue `"."`
   */
  rootPath?: string;
  /**
   * Path to the module into wich the module list is written.
   *
   * @defaultValue `${rootPath}/main.ts`.
   */
  outputPath?: string;
  /**
   * Prettier options. If explicitely set to false, the code is not formatted.
   *
   * @see {@link FormatOptions} for the list of options.
   */
  formatOptions?: FormatOptions | false;
};

/**
 *
 * @param options See {@link ModuleListOptions}
 * @returns A vite plugin that writes a module that dynamically imports modules found in a folder.
 */
export default function moduleList({
  mode = "full-dynamic",
  rootPath = ".",
  outputPath = `${rootPath}/main.ts`,
  formatOptions,
}: ModuleListOptions): PluginOption {
  const resolvedRootPath = resolve(rootPath);
  return {
    name: "module-list",
    async configureServer(server) {
      await writeModuleList(rootPath, outputPath, formatOptions, mode);
      server.watcher.on("all", async (eventName, filePath) => {
        if (eventName !== "add" && eventName !== "unlink") {
          return;
        }
        const resolvedFilePath = resolve(filePath);
        if (
          resolvedFilePath === outputPath ||
          !resolvedFilePath.startsWith(resolvedRootPath)
        ) {
          return;
        }
        await writeModuleList(rootPath, outputPath, formatOptions, mode);
      });
    },
  };
}
